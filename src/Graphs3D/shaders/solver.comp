#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int nodesCount;
    float dt;
    float sigma2;
    uint edgesCount;
    float clampAcc;
    float fieldSize;
    float cellSize;
    float maxDist;
    int speciesCount;
    float damping;
    int trackedIdx;
    float maxForce;
    float amp;
    int cellCount;
    int totalCellCount;
    ivec4 disabled[4];
};

struct Node
{
   vec4 position;
   vec4 velocity;
   int species;
   int flags;
   int  cellIndex;
   int  _pad1;
};

struct Edge
{
    uint a;
    uint b;
    float restLength;
    int player;
    int flags;
};

layout(std140, binding = 0) uniform ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) readonly buffer InputBuffer
{
    Node inNodes[];
};

layout(std430, binding = 2) writeonly buffer OutputBuffer
{
    Node outNodes[];
};

layout(std430, binding = 3) writeonly buffer EdgesBuffer
{
    Edge edges[];
};

layout(std430, binding = 5) writeonly buffer TrackingBuffer
{
    Node tracked;
};

layout(std430, binding = 6) buffer CellCount {
    uint cellCounts[];
};

layout(std430, binding = 7) buffer CellOffsets {
    uint cellOffsets[];
};

layout(std430, binding = 8) buffer ParticleIndices {
    uint particleIndices[];
};

layout(std430, binding = 10) buffer Neighbors {
    uint neighbours[];
};

layout(std430, binding = 11) buffer NeighborsStart {
    uint neighboursStart[];
};

layout(std430, binding = 12) buffer NeighborsCount {
    uint neighboursCount[];
};

layout(std430, binding = 13) buffer RestLengths {
    float restLengths[];
};


void update_one(uint idx)
{
    float uSpringK = 4.0;
    float uRepulsionK = 200;
    float uDamping = 0.95;
    float uMaxStep = 3;
    float epsilon = 0.1;
    float maxSpringForce = 100.0;

    Node p = inNodes[idx];
    
    vec3 pos = p.position.xyz;
    vec3 vel = p.velocity.xyz;
    vec3 force = vec3(0.0);

    uint neighStart = neighboursStart[idx];
    uint neighCount = neighboursCount[idx];
    for (uint i = 0; i < neighCount; i++)
    {
        uint neighIdx = neighStart + i;
        uint otherIdx = neighbours[neighIdx];

        vec3 d = inNodes[otherIdx].position.xyz - pos;
        float dist = length(d) + 1e-6;
        float delta = dist - restLengths[neighIdx];
        force += (d / dist) * (uSpringK * delta);
    }

    // Repulsion
    for (uint j = 0; j < config.nodesCount; j++)
    {
        if (j == idx) continue;
        vec3 d = pos - inNodes[j].position.xyz;
        float r2 = dot(d, d) + 0.1;
        if (r2 > epsilon)
            force += d * (uRepulsionK / (r2 * sqrt(r2)));
    }

    // Integrate
    vel += force * config.dt;
    vel *= uDamping;

    float stepLen = length(vel);
    if (stepLen > uMaxStep)
        vel *= uMaxStep / stepLen;

    pos += vel * config.dt;

    p.velocity = vec4(vel, 0);
    p.position = vec4(pos, 1.0);
    outNodes[idx] = p;

    if (config.trackedIdx > -1 && config.trackedIdx == idx)
    {
        p.flags = 1;
        tracked = p;
    }
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >=0 && idx < config.nodesCount) 
    {
        update_one(idx);


    }
}