#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int nodesCount;
    float dt;
    float sigma2;
    uint edgesCount;
    int useCells;
    float fieldSize;
    float cellSize;
    float maxDist;
    float gridSize;
    float damping;
    int trackedIdx;
    float maxForce;
    float amp;
    int cellCount;
    int totalCellCount;
    vec4 minBounds;
    vec4 maxBounds;
    int marker1;
    int marker2;
    float markerT;
};

struct Node
{
   vec4 position;
   vec4 velocity;
   vec4 prevForce;
   int player;
   int flags;
   int  cellIndex;
   int level;
   int leaf;
   int win;
   int _pad1;
   int _pad2;
};

struct Edge
{
    uint a;
    uint b;
    float restLength;
    int player;
    int flags;
};

layout(std140, binding = 0) uniform ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) readonly buffer InputBuffer
{
    Node inNodes[];
};

layout(std430, binding = 2) writeonly buffer OutputBuffer
{
    Node outNodes[];
};

layout(std430, binding = 3) writeonly buffer EdgesBuffer
{
    Edge edges[];
};

layout(std430, binding = 5) writeonly buffer TrackingBuffer
{
    Node tracked;
};

layout(std430, binding = 6) buffer CellCount {
    uint cellCounts[];
};

layout(std430, binding = 7) buffer CellOffsets {
    uint cellOffsets[];
};

layout(std430, binding = 8) buffer ParticleIndices {
    uint nodesIndices[];
};

layout(std430, binding = 10) buffer Neighbors {
    uint neighbours[];
};

layout(std430, binding = 11) buffer NeighborsStart {
    uint neighboursStart[];
};

layout(std430, binding = 12) buffer NeighborsCount {
    uint neighboursCount[];
};

layout(std430, binding = 13) buffer RestLengths {
    float restLengths[];
};

vec3 repulsion_single(vec3 d, float strength)
{
    float epsilon = 0.1;
    float r2 = dot(d, d) + epsilon;
    if (r2 > epsilon)
            return d * (strength / (r2 * sqrt(r2)));

    return vec3(0);
}

vec3 repulsion_all(uint idx, vec3 pos, float strength)
{
    vec3 force = vec3(0.0);
    for (uint j = 0; j < config.nodesCount; j++)
    {
        if (j == idx) continue;
        vec3 d = pos - inNodes[j].position.xyz;
        force += repulsion_single(d, strength);
    }

    return force;
}

vec3 repulsion_level4(uint idx, vec3 pos, float strength, float hopDecay)
{
    vec3 force = vec3(0.0);
    uint start1 = neighboursStart[idx];
    uint count1 = neighboursCount[idx];

    // -------- depth 1 --------
    for (uint i = 0; i < count1; i++)
    {
        uint n1 = neighbours[start1 + i];
        vec3 d1 = pos - inNodes[n1].position.xyz;
        force += repulsion_single(d1, strength);
    
        // -------- depth 2 --------
        uint start2 = neighboursStart[n1];
        uint count2 = neighboursCount[n1];

        for (uint j = 0; j < count2; j++)
        {
            uint n2 = neighbours[start2 + j];
            if (n2 == idx) continue;

            vec3 d2 = pos - inNodes[n2].position.xyz;
            force += repulsion_single(d2, strength * hopDecay);

            // -------- depth 3 --------
            uint start3 = neighboursStart[n2];
            uint count3 = neighboursCount[n2];

            for (uint k = 0; k < count3; k++)
            {
                uint n3 = neighbours[start3 + k];
                if (n3 == idx) continue;

                vec3 d3 = pos - inNodes[n3].position.xyz;
                force += repulsion_single(d3, strength * hopDecay * hopDecay);

                // -------- depth 4 --------
                uint start4 = neighboursStart[n3];
                uint count4 = neighboursCount[n3];

                for (uint l = 0; l < count4; l++)
                {
                    uint n4 = neighbours[start4 + l];
                    if (n4 == idx) continue;

                    vec3 d4 = pos - inNodes[n4].position.xyz;
                    force += repulsion_single(d4, strength * hopDecay * hopDecay * hopDecay);
                }
            }
        }
    }

    return force;
}

vec3 repulsion_cells(uint idx, vec3 pos, float strength)
{
    Node node = inNodes[idx];
    int cellCount2 = config.cellCount * config.cellCount;
    int gridX = node.cellIndex % config.cellCount;
    int gridY = (node.cellIndex / config.cellCount) % config.cellCount;
    int gridZ = node.cellIndex / (cellCount2);
    ivec3 main = ivec3(gridX, gridY, gridZ);

    vec3 force = vec3(0.0);
    uint localCount = 0;
    for (int dz = -1; dz <= 1; dz++)
    for (int dy = -1; dy <= 1; dy++)
    for (int dx = -1; dx <= 1; dx++)
    {
        ivec3 cell = main + ivec3(dx, dy, dz);
        if (cell.x<0 || cell.x >= config.cellCount) continue;
        if (cell.y<0 || cell.y >= config.cellCount) continue;
        if (cell.z<0 || cell.z >= config.cellCount) continue;

        uint cellIdx = cell.x +
             cell.y * config.cellCount +
             cell.z * cellCount2;

        uint offset = cellOffsets[cellIdx];
        uint count = cellCounts[cellIdx];
        for(uint indiceIdx = offset; indiceIdx<offset + count; indiceIdx++)
        {
            uint otherIdx = nodesIndices[indiceIdx];
            if (idx != otherIdx)
            {
                localCount++;
                vec3 d = pos - inNodes[otherIdx].position.xyz;
                force += repulsion_single(d, strength);

                //float r = length(d);
                //float cutoff = config.cellSize * 1.5;
                //float w = smoothstep(cutoff, 0.0, r);
                //force += repulsion_single(d, strength * w);
            }
        }
    }

    //force *= inversesqrt(float(localCount) + 1.0);

    return force;
}

vec3 flatten_force(uint idx, vec3 pos, float strength)
{
    uint start = neighboursStart[idx];
    uint count = neighboursCount[idx];

    if (count < 2)
        return vec3(0.0);

    vec3 avg = vec3(0.0);

    for (uint i = 0; i < count; i++)
    {
        uint n = neighbours[start + i];
        avg += inNodes[n].position.xyz;
    }

    avg /= float(count);

    // Laplacian force
    return strength * (avg - pos);
}

void update_one(uint idx)
{
    float uSpringK = 40.0;
    float uRepulsionK = 2000;
    float uFlatteningK = 1.0;
    float uDamping = 0.9;
    float uMaxStep = 3;
    float maxSpringForce = 500.0;

    float uHopDecay = 1;

    Node p = inNodes[idx];
    
    vec3 pos = p.position.xyz;
    vec3 vel = p.velocity.xyz;
    vec3 force = vec3(0.0);

    uint neighStart = neighboursStart[idx];
    uint neighCount = neighboursCount[idx];
    for (uint i = 0; i < neighCount; i++)
    {
        uint neighIdx = neighStart + i;
        uint otherIdx = neighbours[neighIdx];

        vec3 d = inNodes[otherIdx].position.xyz - pos;
        float dist = length(d) + 1e-6;
        float delta = dist - restLengths[neighIdx];
        force += (d / dist) * (uSpringK * delta);
    }

    // Repulsion
    if (config.useCells == 0)
        force += repulsion_level4(idx, pos, uRepulsionK, uHopDecay);
    else
        force += repulsion_cells(idx, pos, uRepulsionK);


    //flattening
    force += flatten_force(idx, pos, uFlatteningK);

    // Integrate
    vel += force * config.dt;
    vel *= uDamping;

    float stepLen = length(vel);
    if (stepLen > uMaxStep)
        vel *= uMaxStep / stepLen;

    pos += vel * config.dt;

    p.velocity = vec4(vel, 0);
    p.position = vec4(pos, 1.0);
    p.prevForce = vec4(force, 0);
    outNodes[idx] = p;

    if (config.trackedIdx > -1 && config.trackedIdx == idx)
    {
        tracked = p;
    }
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx < config.nodesCount) 
    {
        update_one(idx);
    }
    else if (idx == config.nodesCount)
    {
        Node marker;
        marker.position = vec4(0,0,0,0);
        marker.flags = 2;
        if (config.marker1 != -1)
        {
            marker = inNodes[config.marker1];
            marker.flags = 1;
            if (config.marker2 != -1)
            {
                float progress = clamp(config.markerT, 0, 1);
                Node target = inNodes[config.marker2];
                marker.position += (target.position - marker.position) * progress;
            }
        }

        outNodes[idx] = marker;
    }
}