#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int nodesCount;
    float dt;
    float sigma2;
    uint edgesCount;
    int useCells;
    float fieldSize;
    float cellSize;
    float maxDist;
    float gridSize;
    float damping;
    int trackedIdx;
    float maxForce;
    float amp;
    int cellCount;
    int totalCellCount;
    vec4 minBounds;
    vec4 maxBounds;
    int marker1;
    int marker2;
    float markerT;
};

struct Node
{
   vec4 position;
   vec4 velocity;
   vec4 prevForce;
   int player;
   int flags;
   int  cellIndex;
   int level;
};

layout(std140, binding = 0) uniform ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) buffer InputBuffer
{
    Node nodes[];
};

layout(std430, binding = 4) buffer Bounds {
    uvec4 minBound;
    uvec4 maxBound;
};

uint floatToOrderedUint(float f)
{
    uint u = floatBitsToUint(f);
    return (u & 0x80000000u) != 0u ? ~u : (u | 0x80000000u);
}

float orderedUintToFloat(uint u)
{
    u = (u & 0x80000000u) != 0u ? (u & 0x7FFFFFFFu) : ~u;
    return uintBitsToFloat(u);
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >=0 && idx < config.nodesCount) 
    {
        uint ox = floatToOrderedUint(nodes[idx].position.x);
        uint oy = floatToOrderedUint(nodes[idx].position.y);
        uint oz = floatToOrderedUint(nodes[idx].position.z);

        atomicMin(minBound.x, ox);
        atomicMin(minBound.y, oy);
        atomicMin(minBound.z, oz);

        atomicMax(maxBound.x, ox);
        atomicMax(maxBound.y, oy);
        atomicMax(maxBound.z, oz);
    }
}